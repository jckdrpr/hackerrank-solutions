{-# OPTIONS_GHC -Wall #-}
{-# OPTIONS_GHC -Werror #-}

module Recursion
  ( fibonacci
  , recursion
  ) where

import Control.Monad
  ( forM_
  , replicateM_
  )
import Data.List

import Data.Ord (comparing)

import qualified Data.Map as Map
import qualified Data.Set as Set
import qualified Data.Char as Char

import Introduction
  ( Point
  , perimeter
  , vcross
  )


-- COMPUTING THE GCD ------------------------------------------------------------------------------

{-| Compoute the greatest common divisor of two numbers -}
gcd' :: (Integral a) => a -> a -> a
gcd' m n
  | m > n = gcd' (m - n) n
  | m < n = gcd' (n - m) m
  | otherwise = n

{-|
 - Objective
 - In this challenge, we learn how to compute GCD using the Euclidean algorithm.
 -
 - Given two integers, a and b, a recursive technique to find their GCD is the Euclidean Algorithm.
 -
 - The algorithm states that, for computing the GCD of two positive integers a and b, if a and b
 - are equal, gcd(a, b) = a. Otherwise gcd(a, b) = gcd(a - b, a) if a > b. There are a few
 - optimizations that can be made to the above logic to arrive at a more efficient implementation.
 -
 -
 - Input Format - One line of input containing  space separated integers.
 -
 - Output Format - Output one integer, the GCD of the two given numbers.
 -}
mainGCD :: IO ()
mainGCD =
  getLine >>= print . uncurry gcd' . (\[x, y] -> (x, y)) . map (read :: String -> Int) . words


-- FIBONACCI NUMBERS ------------------------------------------------------------------------------

{-|
 - Infinite list of fibonacci numbers. To get nth just do fibonacci !! n
 -}
fibonacci :: [Integer]
fibonacci =
  0 : 1 : zipWith (+) fibonacci (tail fibonacci)

{-|
 - Objective:- In this challenge, we learn about using the Fibonacci Function.
 -
 - The Fibonacci Series:
 - The Fibonacci sequence begins with 0 and 1. These are the first and second terms, respectively.
 - After this, every element is the sum of the preceding elements:
 -
 - Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)
 -
 - Task
 - Given the starter code, complete the Fibonacci function to return the Nth term.
 -
 - The overall equation is:
 -
 -              = 0 , n = 1
 - Fibonacci(n) = 1 , n = 2
 -                Fibonacci(n-1) + Fibonacci(n-2)  , n > 2
 - Input Format - One line of input, the integer .
 -}
mainFibonacci :: IO ()
mainFibonacci =
  readLn >>= (\n -> print $ fibonacci !! n)


-- PASCAL'S TRIANGLE ------------------------------------------------------------------------------

{-|
 - Returns an infinite list of pascal triangle rows.
 -}
pascal :: [[Integer]]
pascal =
  map init nCr
    where
      nVec :: [Integer] -> [Integer]
      nVec [] = error "This cannot happen"
      nVec [0] = [0]
      nVec [_] = error "This cannot happen"
      nVec (y1 : y2 : ys) =
        (y1 + y2) : nVec (y2 : ys)

      nCr :: [[Integer]]
      nCr = [1, 0] : [1, 1, 0] : map (\x -> 1 : nVec x) (tail nCr)

{-|
 - For a given integer K, print the first K rows of Pascal's Triangle. Print each row with each
 - value separated by a single space. The value at the nth row and rth column of the triangle is
 - equal to n! / (r! * (n - r)!) where indexing starts from 0. These values are the binomial
 - coefficients.
 -
 - The Pascal Triangle:
 - 1
 - 1 1
 - 1 2 1
 - 1 3 3 1
 - 1 4 6 4 1
 - ....
 - Input Format
 -
 - A single line of input, integer K.
 -}
mainPascal :: IO ()
mainPascal =
  readLn >>= (\n -> putStr . unlines . map (unwords . map show) $ take n pascal)


-- FUNCTIONS AND FRACTALS: SIERPINSKI TRIANGLES ---------------------------------------------------

-- | appends and prepends n underbars to a given string
-- e.g. ubars 3 "aa"
-- ___aa___
ubars :: Int -> String -> String
ubars n lst =
  replicate n '_' ++ lst ++ replicate n '_'


{-| Constructs a trianle of 1's and underscores of the given height -}
-- n ones prepended to others which are prepended and appended with 1 '_'
-- e.g. triangle 5
-- __1__
-- _111_
-- 11111
triangle :: Int -> [String]
triangle 0 = []
triangle 1 = ["1"]
triangle n =
  replicate n '1' : map (ubars 1) (triangle (n - 2))


{-|
 - Generate the ever popular sierpinski triangle using '1' and '_' on 'rows' number of rows (should
 - be 2^k - 1 where k <- Natural numbers and 'n' recursive depth. more the n more preety the
 - pattern and will require more number of lines.
 -}
spnsk :: Int -> Int -> [String]
spnsk rows n
  -- 1 -> generate a triangle of ones with given number of rows
  | n == 1 =
    triangle (2 * rows + 1)
  -- construct bottom half by putting two of them (smaller) side-by-side
  -- construct top half by padding it (smaller) with '_'
  -- and just put them together
  | otherwise =
    zipWith (\x y -> x ++ '_' : y) smaller smaller ++ map (ubars (m + 1)) smaller

  where
    m  = rows `div` 2
    -- n -> generate pattern for n - 1: smaller
    smaller = spnsk m (n - 1)


{-|
 - Generate using '1' and '_' on 'rows' number of rows (should be 2^k - 1 where k <- Natural
 - numbers and 'n' recursive depth. more the n more preety the pattern and will require more
 - number of lines.
 -}
sierpinski :: Int -> Int -> String
sierpinski rows n =
  (unlines . reverse) $ spnsk rows (n + 1)


{-|
 - _______________________________1_______________________________
 - ______________________________111______________________________
 - _____________________________1___1_____________________________
 - ____________________________111_111____________________________
 - ___________________________1_______1___________________________
 - __________________________111_____111__________________________
 - _________________________1___1___1___1_________________________
 - ________________________111_111_111_111________________________
 - _______________________1_______________1_______________________
 - ______________________111_____________111______________________
 - _____________________1___1___________1___1_____________________
 - ____________________111_111_________111_111____________________
 - ___________________1_______1_______1_______1___________________
 - __________________111_____111_____111_____111__________________
 - _________________1___1___1___1___1___1___1___1_________________
 - ________________111_111_111_111_111_111_111_111________________
 - _______________1_______________________________1_______________
 - ______________111_____________________________111______________
 - _____________1___1___________________________1___1_____________
 - ____________111_111_________________________111_111____________
 - ___________1_______1_______________________1_______1___________
 - __________111_____111_____________________111_____111__________
 - _________1___1___1___1___________________1___1___1___1_________
 - ________111_111_111_111_________________111_111_111_111________
 - _______1_______________1_______________1_______________1_______
 - ______111_____________111_____________111_____________111______
 - _____1___1___________1___1___________1___1___________1___1_____
 - ____111_111_________111_111_________111_111_________111_111____
 - ___1_______1_______1_______1_______1_______1_______1_______1___
 - __111_____111_____111_____111_____111_____111_____111_____111__
 - _1___1___1___1___1___1___1___1___1___1___1___1___1___1___1___1_
 - 111_111_111_111_111_111_111_111_111_111_111_111_111_111_111_111
 -
 - Sierpinski Triangle:
 -
 - The Sierpinski Triangle is a pretty fractal which consistes of layers of self-similar triangles,
 - nested inside each other. This challenge involves the construction of such triangles, in the
 - form of ASCII Art. The restriction is, that you need to accomplish this with functional
 - programming, and you cannot declare even local variables!
 -
 - We have to deal with real world constraints, so we cannot keep repeating the pattern infinitely.
 - So, we will provide you a number of iterations, and you need to generate the ASCII version of
 - the Sierpinski Triangle for those many iterations (or, levels of recursion). A few samples are
 - provided below.
 -
 - Iteration #0
 - In the beginning, we simply print a triangle which points upwards. There are 32 rows and 63
 - columns in this matrix. The triangle is composed of underscores and ones as shown below.
 -
 - _______________________________1_______________________________
 - ______________________________111______________________________
 - _____________________________11111_____________________________
 - ____________________________1111111____________________________
 - ___________________________111111111___________________________
 - __________________________11111111111__________________________
 - _________________________1111111111111_________________________
 - ________________________111111111111111________________________
 - _______________________11111111111111111_______________________
 - ______________________1111111111111111111______________________
 - _____________________111111111111111111111_____________________
 - ____________________11111111111111111111111____________________
 - ___________________1111111111111111111111111___________________
 - __________________111111111111111111111111111__________________
 - _________________11111111111111111111111111111_________________
 - ________________1111111111111111111111111111111________________
 - _______________111111111111111111111111111111111_______________
 - ______________11111111111111111111111111111111111______________
 - _____________1111111111111111111111111111111111111_____________
 - ____________111111111111111111111111111111111111111____________
 - ___________11111111111111111111111111111111111111111___________
 - __________1111111111111111111111111111111111111111111__________
 - _________111111111111111111111111111111111111111111111_________
 - ________11111111111111111111111111111111111111111111111________
 - _______1111111111111111111111111111111111111111111111111_______
 - ______111111111111111111111111111111111111111111111111111______
 - _____11111111111111111111111111111111111111111111111111111_____
 - ____1111111111111111111111111111111111111111111111111111111____
 - ___111111111111111111111111111111111111111111111111111111111___
 - __11111111111111111111111111111111111111111111111111111111111__
 - _1111111111111111111111111111111111111111111111111111111111111_
 - 111111111111111111111111111111111111111111111111111111111111111
 -
 - Iteration #1
 - The "Fractalization" now begins. We create a new triangle, which points downwards, and its
 - vertices co-incide with the midpoints of the outer, upward-pointing triangle. The ones are
 - flipped into underscores. Note, that the original upward-pointing triangle has now been split
 - into four segments: one downward-pointing triangle, filled with underscores - and three
 - triangles which point upwards and are filled with ones.
 -
 - _______________________________1_______________________________
 - ______________________________111______________________________
 - _____________________________11111_____________________________
 - ____________________________1111111____________________________
 - ___________________________111111111___________________________
 - __________________________11111111111__________________________
 - _________________________1111111111111_________________________
 - ________________________111111111111111________________________
 - _______________________11111111111111111_______________________
 - ______________________1111111111111111111______________________
 - _____________________111111111111111111111_____________________
 - ____________________11111111111111111111111____________________
 - ___________________1111111111111111111111111___________________
 - __________________111111111111111111111111111__________________
 - _________________11111111111111111111111111111_________________
 - ________________1111111111111111111111111111111________________
 - _______________1_______________________________1_______________
 - ______________111_____________________________111______________
 - _____________11111___________________________11111_____________
 - ____________1111111_________________________1111111____________
 - ___________111111111_______________________111111111___________
 - __________11111111111_____________________11111111111__________
 - _________1111111111111___________________1111111111111_________
 - ________111111111111111_________________111111111111111________
 - _______11111111111111111_______________11111111111111111_______
 - ______1111111111111111111_____________1111111111111111111______
 - _____111111111111111111111___________111111111111111111111_____
 - ____11111111111111111111111_________11111111111111111111111____
 - ___1111111111111111111111111_______1111111111111111111111111___
 - __111111111111111111111111111_____111111111111111111111111111__
 - _11111111111111111111111111111___11111111111111111111111111111_
 - 1111111111111111111111111111111_1111111111111111111111111111111
 -
 - Iteration #2
 - We repeat the process on the three smaller upward-pointing triangles created at the end of
 - Iteration #1. We create a downward pointing triangle inside each of those.
 -
 - _______________________________1_______________________________
 - ______________________________111______________________________
 - _____________________________11111_____________________________
 - ____________________________1111111____________________________
 - ___________________________111111111___________________________
 - __________________________11111111111__________________________
 - _________________________1111111111111_________________________
 - ________________________111111111111111________________________
 - _______________________1_______________1_______________________
 - ______________________111_____________111______________________
 - _____________________11111___________11111_____________________
 - ____________________1111111_________1111111____________________
 - ___________________111111111_______111111111___________________
 - __________________11111111111_____11111111111__________________
 - _________________1111111111111___1111111111111_________________
 - ________________111111111111111_111111111111111________________
 - _______________1_______________________________1_______________
 - ______________111_____________________________111______________
 - _____________11111___________________________11111_____________
 - ____________1111111_________________________1111111____________
 - ___________111111111_______________________111111111___________
 - __________11111111111_____________________11111111111__________
 - _________1111111111111___________________1111111111111_________
 - ________111111111111111_________________111111111111111________
 - _______1_______________1_______________1_______________1_______
 - ______111_____________111_____________111_____________111______
 - _____11111___________11111___________11111___________11111_____
 - ____1111111_________1111111_________1111111_________1111111____
 - ___111111111_______111111111_______111111111_______111111111___
 - __11111111111_____11111111111_____11111111111_____11111111111__
 - _1111111111111___1111111111111___1111111111111___1111111111111_
 - 111111111111111_111111111111111_111111111111111_111111111111111
 - Input Format
 -
 - One Integer N which is the Iteration Number for which you need to generate the Sierpinski
 - triangle, in accordance with the triangles displayed above.
 - Generate the Nth triangle in the series shown above.
 -}
mainSierpinski :: IO ()
mainSierpinski =
  readLn >>= putStr . sierpinski 63


-- STRING MINGLING --------------------------------------------------------------------------------

{-| mingle together multiple strings -}
mingle :: [a] -> [a] -> [a]
mingle [] [] = []
mingle [] _ = error "Well now the strings are not of same length"
mingle _ [] = error "Well now the strings are not of same length"
mingle (x:xs) (y:ys) =
  x : y : mingle xs ys

{-|
 - Pawel and Shaka recently became friends. They believe their friendship will last forever if
 - they merge their favorite strings.
 -
 - The lengths of their favorite strings are the same, n . Mingling two strings, P = p1p2..pn
 - and Q = q1q2...qn, both oflength n, will result in the creation of a new string R of length
 - 2*n. It will have the following structure:
 - R = p1q1p2q2...pnqn
 -
 - You are given two strings P (Pawel's favorite) and Q (Shaka's favorite), determine the mingled
 - string R.
 -
 - Input Format:
 -
 - The first line of input contains the string P.
 - The second line contains Q.
 -
 - Output Format:
 -
 - Print the mingled string, R.
 -}
mainMingle :: IO ()
mainMingle =
  mingle <$> getLine <*> getLine >>= putStrLn


-- STRING-O-PERMUTE -------------------------------------------------------------------------------

{-| swap numbers at even odd -}
swap :: [a] -> [a]
swap [] = []
swap [_] = error "You know swaping even odd positions is hard on odd length strings!!"
swap (x1:x2:xs) =
  x2 : x1 : swap xs

{-|
 - Kazama gave Shaun a string of even length, and asked him to swap the characters at the even
 - positions with the next character. Indexing starts at 0.
 -
 - Formally, given a string str of length L where L is even, Shaun has to swap the characters at
 - position i and i + 1, where i E {0, 2, ... L - 2}.
 -
 - For example, if str = "abcdpqrs", L = 8. We have to swap the characters at positions:
 - {(0, 1), (2, 3), (4, 5), (6, 7)}
 -
 - So, answer will be "badcqpsr".
 -
 - Input Format
 -
 - The first line contains an integer, T, the number of test cases.
 - T lines follow, each containing some string str.
 -
 - Output Format
 -
 - For each test case, print the new string as explained in the problem statement.
 -}
mainSwap :: IO ()
mainSwap =
  readLn >>= (\t -> replicateM_ t (getLine >>= putStrLn . swap))


-- FUNCTIONS AND FRACTALS - RECURSIVE TREES -------------------------------------------------------

-- | creates n lines of a character appended and prepended with underscores
-- (like the bottom half of 'Y'
-- straight 3 'a'
-- ___a___
-- ___a___
-- ___a___
straight :: Int -> Char -> [String]
straight n ch =
  replicate n (ubars n [ch])


-- | creates slanting version (like the top half of 'Y')
-- e.g. slant 3 'a'
-- a_______a
-- _a_____a_
-- __a___a__
-- ___a_a___
slant :: Int -> Char -> [String]
slant 0 ch = [[ch, '_', ch]]
slant n ch =
  ([ch] ++ replicate (2 * n + 1) '_' ++ [ch]) : map (ubars 1) (slant (n - 1) ch)


-- | Creates a Y pattern with the given number of rows and a character
-- e.g. why 3 'a'
-- a_____a
-- _a___a_
-- __a_a__
-- ___a___
-- ___a___
why :: Int -> Char -> [String]
why r ch =
  slant (r - 1) ch ++ straight r ch

{-|
 - Creates the recursive tree drawing
 -}
rTree :: Int -> Int -> Int -> [String]
rTree 1 n co
    | n >= co = why (16 `div` (2^n)) '_'
    | otherwise = why (16 `div` (2^n)) '1'

rTree n r co =
  map (ubar 1) (zip smaller smaller) ++ map (ubars (2^(n - 1) - 1)) (rTree 1 r co)
    where
      smaller       = rTree (n - 1) (r + 1) co
      ubar k (x, y) = x ++ replicate k '_' ++ y


-- | Modifies the tree generated by rTree to fit to the needs of the hacker-rank question
tree :: Int -> [String]
tree n =
  concat (replicate 100 "_") : map (init . ubars 19) (rTree 5 0 n)

{-|
 - _________________________________________________________________________________________________
 - _________________1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_________________
 - __________________1___1___1___1___1___1___1___1___1___1___1___1___1___1___1___1__________________
 - __________________1___1___1___1___1___1___1___1___1___1___1___1___1___1___1___1__________________
 - ___________________1_1_____1_1_____1_1_____1_1_____1_1_____1_1_____1_1_____1_1___________________
 - ____________________1_______1_______1_______1_______1_______1_______1_______1____________________
 - ____________________1_______1_______1_______1_______1_______1_______1_______1____________________
 - ____________________1_______1_______1_______1_______1_______1_______1_______1____________________
 - _____________________1_____1_________1_____1_________1_____1_________1_____1_____________________
 - ______________________1___1___________1___1___________1___1___________1___1______________________
 - _______________________1_1_____________1_1_____________1_1_____________1_1_______________________
 - ________________________1_______________1_______________1_______________1________________________
 - ________________________1_______________1_______________1_______________1________________________
 - ________________________1_______________1_______________1_______________1________________________
 - ________________________1_______________1_______________1_______________1________________________
 - ________________________1_______________1_______________1_______________1________________________
 - _________________________1_____________1_________________1_____________1_________________________
 - __________________________1___________1___________________1___________1__________________________
 - ___________________________1_________1_____________________1_________1___________________________
 - ____________________________1_______1_______________________1_______1____________________________
 - _____________________________1_____1_________________________1_____1_____________________________
 - ______________________________1___1___________________________1___1______________________________
 - _______________________________1_1_____________________________1_1_______________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - _________________________________1_____________________________1_________________________________
 - __________________________________1___________________________1__________________________________
 - ___________________________________1_________________________1___________________________________
 - ____________________________________1_______________________1____________________________________
 - _____________________________________1_____________________1_____________________________________
 - ______________________________________1___________________1______________________________________
 - _______________________________________1_________________1_______________________________________
 - ________________________________________1_______________1________________________________________
 - _________________________________________1_____________1_________________________________________
 - __________________________________________1___________1__________________________________________
 - ___________________________________________1_________1___________________________________________
 - ____________________________________________1_______1____________________________________________
 - _____________________________________________1_____1_____________________________________________
 - ______________________________________________1___1______________________________________________
 - _______________________________________________1_1_______________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 -
 -
 - Creating a Fractal Tree from Y-shaped branches
 -
 - This challenge involves the construction of trees, in the form of ASCII Art. The restriction is,
 - that you need to accomplish this with functional programming, and you cannot declare even local
 - variables!
 -
 - We have to deal with real world constraints, so we cannot keep repeating the pattern infinitely.
 - So, we will provide you a number of iterations, and you need to generate the ASCII version of
 - the Fractal Tree for only those many iterations (or, levels of recursion). A few samples are
 - provided below.
 -
 - Iteration #1
 - In the beginning, we simply create a Y. There are 63 rows and 100 columns in the grid below.
 - The triangle is composed of underscores and ones as shown below. The vertical segment and the
 - slanting segments are both 16 characters in length.
 -
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - ________________________________1_______________________________1________________________________
 - _________________________________1_____________________________1_________________________________
 - __________________________________1___________________________1__________________________________
 - ___________________________________1_________________________1___________________________________
 - ____________________________________1_______________________1____________________________________
 - _____________________________________1_____________________1_____________________________________
 - ______________________________________1___________________1______________________________________
 - _______________________________________1_________________1_______________________________________
 - ________________________________________1_______________1________________________________________
 - _________________________________________1_____________1_________________________________________
 - __________________________________________1___________1__________________________________________
 - ___________________________________________1_________1___________________________________________
 - ____________________________________________1_______1____________________________________________
 - _____________________________________________1_____1_____________________________________________
 - ______________________________________________1___1______________________________________________
 - _______________________________________________1_1_______________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 -
 -
 - Iteration #2
 -
 - At the top of the left and right branches of the first Y, we now add a pair of Y-shapes, which
 - are half the size of the original Y.
 -
 -
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - _________________________________________________________________________________________________
 - ________________________1_______________1_______________1_______________1________________________
 - _________________________1_____________1_________________1_____________1_________________________
 - __________________________1___________1___________________1___________1__________________________
 - ___________________________1_________1_____________________1_________1___________________________
 - ____________________________1_______1_______________________1_______1____________________________
 - _____________________________1_____1_________________________1_____1_____________________________
 - ______________________________1___1___________________________1___1______________________________
 - _______________________________1_1_____________________________1_1_______________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - ________________________________1_______________________________1________________________________
 - _________________________________1_____________________________1_________________________________
 - __________________________________1___________________________1__________________________________
 - ___________________________________1_________________________1___________________________________
 - ____________________________________1_______________________1____________________________________
 - _____________________________________1_____________________1_____________________________________
 - ______________________________________1___________________1______________________________________
 - _______________________________________1_________________1_______________________________________
 - ________________________________________1_______________1________________________________________
 - _________________________________________1_____________1_________________________________________
 - __________________________________________1___________1__________________________________________
 - ___________________________________________1_________1___________________________________________
 - ____________________________________________1_______1____________________________________________
 - _____________________________________________1_____1_____________________________________________
 - ______________________________________________1___1______________________________________________
 - _______________________________________________1_1_______________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 - ________________________________________________1________________________________________________
 -
 -
 - Input Format
 - A single integer, N.
 -
 - Constraints
 - N <= 5
 - And, you need to accomplish this without directly defining any local variables. For example, var
 - and val have been blocked in Scala; def and defn are blocked in Clojure.
 -
 - Output Format
 - The Nth iteration of the Fractal Tree, as shown above. It should be a matrix of 63 rows and 100
 - columns. (i.e. 6300 printable characters) It should be composed entirely of underscores and ones,
 - in a manner similar to the examples provided. Do not include any extra leading or trailing spaces.
 -}
mainTree :: IO ()
mainTree =
  readLn >>= putStr . unlines . tree


-- CONVEX HULL ------------------------------------------------------------------------------------

{-|
 - A Direction data type that describes the type of angle the intersectiono of two lines make
 - a _____b____d
 -        |
 -        |
 -        c
 - a -> b -> c is a clockwise turn
 - c -> b -> a is a counter-clockwise turn
 - a -> b -> d is a Straight line
 -}
data Direction
  = LeftTurn
  | RightTurn
  | Straight
  deriving (Read, Show, Eq)


{-|
 - Given three points in a 2-d space returns the direction of turn from parm1 -> param2 -> param3
 - INSIGHT: cross product of 2 vectors has a direction associated with it using the thumb rule one
 - can clearly see that left-turn => +ive direction on z axis and right-turn => -ive direction
 -}
turnType :: Point -> Point -> Point -> Direction
turnType (xa, ya) (xb, yb) (xc, yc)
  | crossProd < 0 = LeftTurn
  | crossProd > 0 = RightTurn
  | otherwise = Straight
  where
    -- calculate cross product of BA and BC
    crossProd =
      vcross (xa - xb, ya - yb) (xc - xb, yc - yb)


{-|
 - Given a point and a list of points sorts that list by comparing the polar angle that the points
 - make with the given refrence point.
 -}
sortByPolarAngle :: Point -> [Point] -> [Point]
sortByPolarAngle p =
  sortBy (comparing (polarAngle p))


{-|
 - Gives a tuple of the angle between two points and the absolute x distance between them
 -}
polarAngle :: Point -> Point -> (Double, Double)
polarAngle (x0, y0) (x, y) =
  (atan2 (y - y0) (x - x0), abs (x - x0))


{-|
 - Helper Functions:
 - This function when provided with a list of points sorted with respect to a refrence point
 - and singleton list containing the refrence point will return the convex hull for those set
 - of points in linear time.
 -
 - Structure:
 - Angle from a -> b -> c is checked where b and c are in left Argument and a is in the right.
 - firstArgument keeps track of points to scan
 - secondArgument keeps track of the convex hull constructed so far
 -
 - There are three cases to consider:
 - a -> b -> c makes a left turn then simply add b to the result
 - a -> b -> c makes a straight line then simple ignore b
 - a -> b -> c makes a right turn in addition to ignoring b we also need to see if a is valid
 - to do so we pop a from the convexHull and put it back into consideration
 -}
gScan :: [Point] -> [Point] -> [Point]
gScan [] [] = []
gScan _ [] = error "no minY but others passed"
gScan [] ys = ys
gScan [x] ys = x : ys
gScan (b : c : ps) (a : chs) =
  case turnType a b c of
    LeftTurn ->
      gScan (c : ps) (b : a : chs)

    Straight ->
      gScan (c : ps) (a : chs)

    RightTurn ->
      gScan (a : c : ps) chs


{-|
 - Gives the convex Hull of the given set of points in linear-arithmatic time.
 -}
convexHull :: [Point] -> [Point]
convexHull xs =
  let
    minY = minimumBy (comparing snd) xs
  in
    gScan (sortByPolarAngle minY xs ++ [minY]) [minY]


{-|
 - Convex Hull of a set of points, in 2D plane, is a convex polygon with minimum area such that eachx
 - point lies either on the boundary of polygon or inside it.
 -
 - Let's consider a 2D plane, where we plug pegs at the points mentioned. We enclose all the pegs
 - with a elastic band and then release it to take its shape. The closed structure formed by elastic
 - band is similar to that of convex hull.
 -
 - Tasks
 - Given a set of N points, Find the perimeter of the convex hull for the points.
 -
 - Input Format
 - First line of input will contain a integer, N, number of points. Then follow N lines where each
 - line contains the coordinate, xi yi, of ith point.
 -
 - Output Format
 - Print the perimeter of convex hull for the given set of points. An error margin of +/- 0.2 is
 - acceptable.
 -
 - Constraints
 - 3 <= N <= 104
 - 0 <= xi, yi <= 104
 - There exists, at least, three points which are non-colinear.
 -}
mainConvexHull :: IO ()
mainConvexHull =
  getContents >>=
    print . perimeter . convexHull . map ((\[x,y] -> (x,y)) . map read . words) . tail . lines


-- STRING COMPRESSION -----------------------------------------------------------------------------

compress :: String -> String
compress [] = []
compress (x:xs) =
  x : (res ++ compress (dropWhile (== x) xs))
    where
      cfac = length (takeWhile (== x) xs)
      res  = case cfac of
        0 -> ""
        _ -> show (cfac + 1)

{-|
 - Joseph and Jane are making a contest for apes. During the process, they have to communicate
 - frequently with each other. Since they are not completely human, they cannot speak properly. They
 - have to transfer messages using postcards of small sizes.
 - To save space on the small postcards, they devise a string compression algorithm:
 -
 - If a character, ch, occurs n(>1) times in a row, then it will be represented by {ch}{n}, where {x}
 - is the value of x. For example, if the substring is a sequence of 4 'a' ("aaaa"), it will be
 - represented as "a4".
 -
 - If a character,ch , occurs exactly one time in a row, then it will be simply represented as {ch}.
 - For example, if the substring is "a", then it will be represented as "a".
 -
 - Help Joseph to compress a message, msg.
 -
 - Input:- The only line of input contains a string, msg.
 -
 - Output:- Print the string msg as a compressed message.
 -}
mainStrCompress :: IO ()
mainStrCompress =
  getLine >>= putStrLn . compress


-- PREFIX COMPRESSION -----------------------------------------------------------------------------

{-|
 - Finds the larges common prefix for the given to equatable lists
 -}
prefix :: Eq a => [a] -> [a] -> [a]
prefix xs ys =
  map fst (takeWhile (uncurry (==)) (zip xs ys))

{-|
 - Given two string returns their largest prefix and what remains after taking it out from both
 - the strings.
 -}
compression :: String -> String -> [String]
compression xs ys =
  let
    pfix = prefix xs ys
    lfix = length pfix
  in
    map (\x -> (show . length) x ++ (' ':x)) [pfix, drop lfix xs, drop lfix ys]

{-|
 - You are in charge of data transfer between two Data Centers. Each set of data is represented by
 - a pair of strings. Over a period of time you have observed a trend: most of the times both
 - strings share some prefix. You want to utilize this observation to design a data compression
 - algorithm which will be used to reduce amount of data to be transferred.
 -
 - You are given two strings, x and y, representing the data, you need to find the longest common
 - prefix (p) of the two strings. Then you will send substring p, x' and y', where x' and y' are
 - the substring left after stripping from them.
 -
 - For example, if x = "abcdefpr" and y = "abcpqr", then p = "abc", x' = "defpr", y' = "pqr".
 -
 - Input Format
 - The first line contains a single string denoting x.
 - The second line contains a single string denoting y.
 -
 - Constraints:
 - x and y will contain only lowercase Latin characters ('a'-'z').
 -
 - Output Format
 -
 - In first line, print the length of substring p, followed by prefix p. In second line, print the
 - length of substring x', followed by substring x'. Similary in third line, print the length of
 - substring y', followed by substring y'.
 -}
mainPrefixCompress :: IO ()
mainPrefixCompress =
  compression <$> getLine <*> getLine >>= putStrLn . unlines


-- STRING REDUCTIONS ------------------------------------------------------------------------------

{-|
 - Filters out all the repeated elements while preserving the order in which the elements first
 - appear unique elements of a list
 -}
reduction :: (Ord a) => Set.Set a -> [a] -> [a]
reduction _ [] = []
reduction seen (x:xs) =
  if x `Set.member` seen
    then reduction seen xs
    else x : reduction (x `Set.insert` seen) xs

{-|
 - Given a string, str = s1s2..sn, consisting of n lowercase English characters (a-z), remove all
 - of the characters that occurred previously in the string. Formally, remove all characters, si,
 - for: suchthat j, sj = si and j < i
 -
 - Input Format: A single line of input containing a string s of length n.
 -
 - Constraints:
 - * 1 <= n <= 10^5
 - * si E {a, b, ..., z} where 1 <= i <= n
 -
 - Output Format: Print the string after removing all the characters that occurred previously.
 -}
mainReduction :: IO ()
mainReduction =
  getLine >>= putStrLn . reduction Set.empty


-- THE SUM OF POWERS ------------------------------------------------------------------------------

{-|
 - Returns the number of unique ways we can get n by adding kth powers of natural numbers.
 -}
sumOfPows :: Int -> Int -> Int
sumOfPows t k =
  length $ filter (\x -> sum x == t) $ pset t 0 $ takeWhile (<= t) $ map (^k) [1..]
    where
      -- returns the pset of xs | sum xs < t (reduces the search space by quite a lot)
      pset _ _ [] = [[]]
      pset n s (x:xs)
        | s + x > n = pset n s xs
        | otherwise = pset n s xs ++ map (x:) (pset n (s + x) xs)

{-|
 - Find the number of ways that a given integer, X, can be expressed as the sum of the Nth power of
 - unique, natural numbers.
 -
 - Input Format:
 - The first line contains an integer X.
 - The second line contains an integer N.
 -
 - Constraints:
 - * 1 <= X <= 1000
 - * 2 <= N <= 10
 -
 - Output Format: Output a single integer, the answer to the problem explained above.
 -}
mainSumOfPowers :: IO ()
mainSumOfPowers =
  sumOfPows <$> readLn <*> readLn >>= print


-- FILTER ELEMENTS --------------------------------------------------------------------------------

{-|
 - Only elements whose count is greater than k in the given list whilest preserving the first
 - occurance order.
 -}
filterGTk :: (Ord t, Num t) => t -> [t] -> [t]
filterGTk k xs =
  let
    mapF = Map.fromListWith (+) [(x, 1) | x <- xs]
    filterd = filter (\x -> maybe False (>= k) (Map.lookup x mapF)) xs
  in
    if null filterd
      then [ -1 ]
      else reduction Set.empty filterd

{-|
 - Given a list of N integers A = [a1, a2, ..., aN], you have to find those integers which are
 - repeated at least K times. In case no such element exists you have to print -1.
 -
 - If there are multiple elements in A which are repeated at least K times, then print these
 - elements ordered by their first occurrence in the list.
 -
 - Let's say A = [4, 5, 2, 5, 4, 3, 1, 3, 4] and K = 2. Then the output is
 -
 - 4 5 3
 - because these numbers have appeared at least 2 times.
 - Among these numbers,
 - 4 has appeared first at position 1,
 - 5 has appeared next at position 2,
 - and 3 has appeared thereafter at position 6.
 - That's why, we print in the order 4, 5 and finally 3.
 -
 - Input
 - First line contains an integer, T, the number of test cases. Then T test cases follow.
 - Each test case consist of two lines. First line will contain two space separated integers, N and
 - K, where N is the size of list A, and K represents the repetition count. In the second line,
 - there are N space separated integers which represent the elements of list A = [a1, a2, ..., aN].
 -
 - Output
 - For each test case, you have to print all those integers which have appeared in the list at least
 - K times in the order of their first appearance, separated by space. If no such element exists,
 - then print -1.
 -
 - Constraints
 - 1 <= T <= 10
 - 1 <= N <= 10000
 - 1 <= K <= N
 - 1 <= ai <= 10^9
 -}
mainFilterGTk :: IO ()
mainFilterGTk = do
  t <- readLn :: IO Int
  forM_ [1..t] $ \_ -> do
    [_,k] <- fmap (map read . words) getLine
    getLine >>= putStrLn . unwords . map show . filterGTk k . map (read :: String -> Int) . words


-- SUPER DIGIT ------------------------------------------------------------------------------------

{-|
 - Returns super digit of a number
 - We define super digit of an integer x using the following rules:
 -
 - Iff x has only 1 digit, then its super digit is x.
 - Otherwise, the super digit of x is equal to the super digit of the digit-sum of x. Here,
 - digit-sum of a number is defined as the sum of its digits.
 -}
superDigit :: String -> Int
superDigit [a] = Char.digitToInt a
superDigit xs =
  superDigit . show . sum $ map Char.digitToInt xs

{-|
 - We define super digit of an integer x using the following rules:
 -
 - Iff x has only 1 digit, then its super digit is x.
 - Otherwise, the super digit of x is equal to the super digit of the digit-sum of x. Here,
 - digit-sum of a number is defined as the sum of its digits.
 - For example, super digit of 9875 will be calculated as:
 -
 - super-digit(9875) = super-digit(9+8+7+5)
 -                   = super-digit(29)
 -                   = super-digit(2+9)
 -                   = super-digit(11)
 -                   = super-digit(1+1)
 -                   = super-digit(2)
 -                   = 2.
 - You are given two numbers - n k. You have to calculate the super digit of P.
 -
 - P is created when number n is concatenated k times. That is, if n = 123 and k = 3, then
 - P = 123123123.
 -
 - Input Format
 - Input will contain two space separated integers, n and k.
 -
 - Output Format
 -
 - Output the super digit of P, where P is created as described above.
 -
 - Constraint
 - * 1 <= n <= n^100000
 - * 1 <= k <= 10^5
 -}
mainSuperDigit :: IO ()
mainSuperDigit = do
  (n, k) <- fmap ((\[n, k] -> (n, read k)) . words) getLine
  print . superDigit . show $ k * superDigit n


-- CONCAVE POLYGON --------------------------------------------------------------------------------

-- | Slightly modified gScan will treat Straight and LeftTurn similarly.
gScan' :: [Point] -> [Point] -> [Point]
gScan' [] [] = []
gScan' _ [] = error "no minY but others passed"
gScan' [] ys = ys
gScan' [x] ys = x : ys
gScan' (b : c : ps) (a : chs) =
  case turnType a b c of
    LeftTurn ->
      gScan' (c : ps) (b : a : chs)

    Straight ->
      gScan' (c : ps) (a : chs)

    RightTurn ->
      gScan' (a : c : ps) chs


{-|
 - Gives the convex Hull of the given set of points in linear-arithmatic time.
 - Uses the modified gScan. (Will consider points on boundry also part of the convex hull).
 -}
convexHull' :: [Point] -> [Point]
convexHull' xs =
  let
    minY = minimumBy (comparing snd) xs
  in
    gScan' (sortByPolarAngle minY xs ++ [minY]) [minY]

-- | Checks wether the polygon is concave or not
-- NOTE: gScan needs to be altered a bit for this to work correctly
-- i.e. in case of string line don't igore the point but treat it like a LeftTurn.
isConcave :: [Point] -> String
isConcave xs =
  if length (convexHull' xs) <= length xs then "YES" else "NO"

{-|
 - You are given the cartesian coordinates of a set of points in a 2-d plane (in no particular
 - order). Each of these points is a corner point of some Polygon, P, which is not self-intersecting
 - in nature. Can you determine whether or not P is a concave polygon?
 -
 - Input Format
 -
 - The first line contains an integer, N, denoting the number of points.
 - The N subsequent lines each contain 2 space-separated integers denoting the respective x and y
 - coordinates of a point.
 -
 - Constraints
 - * 3 <= N <= 1000
 - * 0 <= x, y <= 1000
 -
 - Output Format Print YES if P is a concave polygon; otherwise, print NO.
 -}
mainIsConcave :: IO ()
mainIsConcave =
  getLine >> getContents >>=
      putStr . isConcave . map ((\[x, y] -> (x, y)) . map read . words) . lines


---------------------------------------------------------------------------------------------------

recursion :: [(String, IO ())]
recursion =
  [ ("gcd", mainGCD)
  , ("fibonacci", mainFibonacci)
  , ("pascal", mainPascal)
  , ("sierpinski", mainSierpinski)
  , ("mingle", mainMingle)
  , ("swap", mainSwap)
  , ("tree", mainTree)
  , ("convexHull", mainConvexHull)
  , ("stringCompression", mainStrCompress)
  , ("prefixCompression", mainPrefixCompress)
  , ("reduction", mainReduction)
  , ("sumOfPowers", mainSumOfPowers)
  , ("filterGTk", mainFilterGTk)
  , ("superDigit", mainSuperDigit)
  , ("concavePolygon", mainIsConcave)
  ]

